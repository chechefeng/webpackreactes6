'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _zscroller = require('zscroller');

var _zscroller2 = _interopRequireDefault(_zscroller);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var SCROLLVIEW = 'ScrollView';
var INNERVIEW = 'InnerScrollView';

// https://github.com/facebook/react-native/blob/master/Libraries/Components/ScrollView/ScrollView.js
// https://facebook.github.io/react-native/docs/refreshcontrol.html

/* eslint react/prop-types: 0, react/sort-comp: 0, no-unused-expressions: 0 */

var propTypes = {
  children: _propTypes2['default'].any,
  className: _propTypes2['default'].string,
  prefixCls: _propTypes2['default'].string,
  listPrefixCls: _propTypes2['default'].string,
  listViewPrefixCls: _propTypes2['default'].string,
  style: _propTypes2['default'].object,
  contentContainerStyle: _propTypes2['default'].object,
  onScroll: _propTypes2['default'].func,
  scrollEventThrottle: _propTypes2['default'].number,
  removeClippedSubviews: _propTypes2['default'].bool, // offscreen views are removed
  refreshControl: _propTypes2['default'].element
};
var styles = {
  base: {
    position: 'relative',
    overflow: 'auto',
    WebkitOverflowScrolling: 'touch',
    flex: 1
  },
  zScroller: {
    position: 'relative',
    overflow: 'hidden',
    flex: 1
  }
};

var ScrollView = function (_React$Component) {
  (0, _inherits3['default'])(ScrollView, _React$Component);

  function ScrollView() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3['default'])(this, ScrollView);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3['default'])(this, (_ref = ScrollView.__proto__ || Object.getPrototypeOf(ScrollView)).call.apply(_ref, [this].concat(args))), _this), _this.throttleScroll = function () {
      var handleScroll = function handleScroll() {};
      if (_this.props.scrollEventThrottle && _this.props.onScroll) {
        handleScroll = (0, _util.throttle)(function (e) {
          _this.props.onScroll && _this.props.onScroll(e);
        }, _this.props.scrollEventThrottle);
      }
      return handleScroll;
    }, _this.scrollingComplete = function () {
      // console.log('scrolling complete');
      if (_this.props.refreshControl && _this.refs.refreshControl && _this.refs.refreshControl.state.deactive) {
        _this.refs.refreshControl.setState({ deactive: false });
      }
    }, _temp), (0, _possibleConstructorReturn3['default'])(_this, _ret);
  }

  (0, _createClass3['default'])(ScrollView, [{
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      // https://stackoverflow.com/questions/1386696/make-scrollleft-scrolltop-changes-not-trigger-scroll-event
      // 问题情景：用户滚动内容后，改变 dataSource 触发 ListView componentWillReceiveProps
      // 内容变化后 scrollTop 如果改变、会自动触发 scroll 事件，而此事件应该避免被执行
      if ((this.props.dataSource !== nextProps.dataSource || this.props.initialListSize !== nextProps.initialListSize) && this.tsExec) {
        // console.log('componentWillUpdate');
        if (this.props.stickyHeader || this.props.useBodyScroll) {
          window.removeEventListener('scroll', this.tsExec);
        } else if (!this.props.useZscroller) {
          // not handle useZscroller now. todo
          _reactDom2['default'].findDOMNode(this.refs[SCROLLVIEW]).removeEventListener('scroll', this.tsExec);
        }
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _this2 = this;

      // console.log('componentDidUpdate');
      if (prevProps.refreshControl && this.props.refreshControl) {
        var preRefreshing = prevProps.refreshControl.props.refreshing;
        var nowRefreshing = this.props.refreshControl.props.refreshing;
        if (preRefreshing && !nowRefreshing && this.refreshControlRefresh) {
          this.refreshControlRefresh();
        } else if (!this.manuallyRefresh && !preRefreshing && nowRefreshing) {
          this.domScroller.scroller.triggerPullToRefresh();
        }
      }
      // handle componentWillUpdate accordingly
      if ((this.props.dataSource !== prevProps.dataSource || this.props.initialListSize !== prevProps.initialListSize) && this.tsExec) {
        // console.log('componentDidUpdate');
        setTimeout(function () {
          if (_this2.props.stickyHeader || _this2.props.useBodyScroll) {
            window.addEventListener('scroll', _this2.tsExec);
          } else if (!_this2.props.useZscroller) {
            // not handle useZscroller now. todo
            _reactDom2['default'].findDOMNode(_this2.refs[SCROLLVIEW]).addEventListener('scroll', _this2.tsExec);
          }
        }, 0);
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this3 = this;

      this.tsExec = this.throttleScroll();
      // IE supports onresize on all HTML elements.
      // In all other Browsers the onresize is only available at the window object
      this.onLayout = function () {
        return _this3.props.onLayout({
          nativeEvent: { layout: { width: window.innerWidth, height: window.innerHeight } }
        });
      };
      var ele = _reactDom2['default'].findDOMNode(this.refs[SCROLLVIEW]);

      if (this.props.stickyHeader || this.props.useBodyScroll) {
        window.addEventListener('scroll', this.tsExec);
        window.addEventListener('resize', this.onLayout);
        // todo
        // ele.addEventListener('resize', this.onContentSizeChange);
      } else {
        // todo
        // ele.addEventListener('resize', this.onLayout);
        // ReactDOM.findDOMNode(this.refs[INNERVIEW])
        // .addEventListener('resize', this.onContentSizeChange);
        if (this.props.useZscroller) {
          this.renderZscroller();
        } else {
          ele.addEventListener('scroll', this.tsExec);
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.props.stickyHeader || this.props.useBodyScroll) {
        window.removeEventListener('scroll', this.tsExec);
        window.removeEventListener('resize', this.onLayout);
      } else if (this.props.useZscroller) {
        this.domScroller.destroy();
      } else {
        _reactDom2['default'].findDOMNode(this.refs[SCROLLVIEW]).removeEventListener('scroll', this.tsExec);
      }
    }
  }, {
    key: 'scrollTo',
    value: function scrollTo() {
      if (this.props.stickyHeader || this.props.useBodyScroll) {
        var _window;

        (_window = window).scrollTo.apply(_window, arguments);
      } else if (this.props.useZscroller) {
        var _domScroller$scroller;

        // it will change zScroller's dimensions on data loaded, so it needs fire reflow.
        this.domScroller.reflow();
        (_domScroller$scroller = this.domScroller.scroller).scrollTo.apply(_domScroller$scroller, arguments);
      } else {
        var ele = _reactDom2['default'].findDOMNode(this.refs[SCROLLVIEW]);
        ele.scrollLeft = arguments.length <= 0 ? undefined : arguments[0];
        ele.scrollTop = arguments.length <= 1 ? undefined : arguments[1];
      }
    }
  }, {
    key: 'renderZscroller',
    value: function renderZscroller() {
      var _this4 = this;

      var _props = this.props,
          scrollerOptions = _props.scrollerOptions,
          refreshControl = _props.refreshControl;
      // console.log('onRefresh will not change', refreshControl.props.onRefresh.toString());

      this.domScroller = new _zscroller2['default'](_reactDom2['default'].findDOMNode(this.refs[INNERVIEW]), (0, _objectAssign2['default'])({}, {
        scrollingX: false,
        onScroll: this.tsExec,
        scrollingComplete: this.scrollingComplete
      }, scrollerOptions));
      if (refreshControl) {
        var scroller = this.domScroller.scroller;
        var _refreshControl$props = refreshControl.props,
            distanceToRefresh = _refreshControl$props.distanceToRefresh,
            onRefresh = _refreshControl$props.onRefresh;

        scroller.activatePullToRefresh(distanceToRefresh, function () {
          // console.log('first reach the distance');
          _this4.manuallyRefresh = true;
          _this4.overDistanceThenRelease = false;
          _this4.refs.refreshControl && _this4.refs.refreshControl.setState({ active: true });
        }, function () {
          // console.log('back to the distance', this.overDistanceThenRelease);
          _this4.manuallyRefresh = false;
          _this4.refs.refreshControl && _this4.refs.refreshControl.setState({
            deactive: _this4.overDistanceThenRelease,
            active: false,
            loadingState: false
          });
        }, function () {
          // console.log('Over distance and release to loading');
          _this4.overDistanceThenRelease = true;
          _this4.refs.refreshControl && _this4.refs.refreshControl.setState({
            deactive: false,
            loadingState: true
          });
          var finishPullToRefresh = function finishPullToRefresh() {
            scroller.finishPullToRefresh();
            _this4.refreshControlRefresh = null;
          };
          Promise.all([new Promise(function (resolve) {
            onRefresh();
            _this4.refreshControlRefresh = resolve;
          }),
          // at lease 1s for ux
          new Promise(function (resolve) {
            return setTimeout(resolve, 1000);
          })]).then(finishPullToRefresh, finishPullToRefresh);
        });
        if (refreshControl.props.refreshing) {
          scroller.triggerPullToRefresh();
        }
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _classNames, _classNames2;

      var _props2 = this.props,
          children = _props2.children,
          className = _props2.className,
          _props2$prefixCls = _props2.prefixCls,
          prefixCls = _props2$prefixCls === undefined ? '' : _props2$prefixCls,
          _props2$listPrefixCls = _props2.listPrefixCls,
          listPrefixCls = _props2$listPrefixCls === undefined ? '' : _props2$listPrefixCls,
          _props2$listViewPrefi = _props2.listViewPrefixCls,
          listViewPrefixCls = _props2$listViewPrefi === undefined ? 'rmc-list-view' : _props2$listViewPrefi,
          _props2$style = _props2.style,
          style = _props2$style === undefined ? {} : _props2$style,
          contentContainerStyle = _props2.contentContainerStyle,
          useZscroller = _props2.useZscroller,
          refreshControl = _props2.refreshControl,
          stickyHeader = _props2.stickyHeader,
          useBodyScroll = _props2.useBodyScroll;


      var styleBase = styles.base;
      if (stickyHeader || useBodyScroll) {
        styleBase = null;
      } else if (useZscroller) {
        styleBase = styles.zScroller;
      }

      var preCls = prefixCls || listViewPrefixCls || '';

      var containerProps = {
        ref: SCROLLVIEW,
        style: (0, _objectAssign2['default'])({}, styleBase, style),
        className: (0, _classnames2['default'])((_classNames = {}, (0, _defineProperty3['default'])(_classNames, className, !!className), (0, _defineProperty3['default'])(_classNames, preCls + '-scrollview', true), _classNames))
      };
      var contentContainerProps = {
        ref: INNERVIEW,
        style: (0, _objectAssign2['default'])({}, { position: 'absolute', minWidth: '100%' }, contentContainerStyle),
        className: (0, _classnames2['default'])((_classNames2 = {}, (0, _defineProperty3['default'])(_classNames2, preCls + '-scrollview-content', true), (0, _defineProperty3['default'])(_classNames2, listPrefixCls, !!listPrefixCls), _classNames2))
      };

      if (refreshControl) {
        return _react2['default'].createElement(
          'div',
          containerProps,
          _react2['default'].createElement(
            'div',
            contentContainerProps,
            _react2['default'].cloneElement(refreshControl, { ref: 'refreshControl' }),
            children
          )
        );
      }

      if (stickyHeader || useBodyScroll) {
        return _react2['default'].createElement(
          'div',
          containerProps,
          children
        );
      }
      return _react2['default'].createElement(
        'div',
        containerProps,
        _react2['default'].createElement(
          'div',
          contentContainerProps,
          children
        )
      );
    }
  }]);
  return ScrollView;
}(_react2['default'].Component);

ScrollView.propTypes = propTypes;
exports['default'] = ScrollView;
module.exports = exports['default'];