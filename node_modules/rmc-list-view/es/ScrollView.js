import _defineProperty from 'babel-runtime/helpers/defineProperty';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import DOMScroller from 'zscroller';
import assign from 'object-assign';
import classNames from 'classnames';
import { throttle } from './util';

var SCROLLVIEW = 'ScrollView';
var INNERVIEW = 'InnerScrollView';

// https://github.com/facebook/react-native/blob/master/Libraries/Components/ScrollView/ScrollView.js
// https://facebook.github.io/react-native/docs/refreshcontrol.html

/* eslint react/prop-types: 0, react/sort-comp: 0, no-unused-expressions: 0 */

var propTypes = {
  children: PropTypes.any,
  className: PropTypes.string,
  prefixCls: PropTypes.string,
  listPrefixCls: PropTypes.string,
  listViewPrefixCls: PropTypes.string,
  style: PropTypes.object,
  contentContainerStyle: PropTypes.object,
  onScroll: PropTypes.func,
  scrollEventThrottle: PropTypes.number,
  removeClippedSubviews: PropTypes.bool, // offscreen views are removed
  refreshControl: PropTypes.element
};
var styles = {
  base: {
    position: 'relative',
    overflow: 'auto',
    WebkitOverflowScrolling: 'touch',
    flex: 1
  },
  zScroller: {
    position: 'relative',
    overflow: 'hidden',
    flex: 1
  }
};

var ScrollView = function (_React$Component) {
  _inherits(ScrollView, _React$Component);

  function ScrollView() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, ScrollView);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ScrollView.__proto__ || Object.getPrototypeOf(ScrollView)).call.apply(_ref, [this].concat(args))), _this), _this.throttleScroll = function () {
      var handleScroll = function handleScroll() {};
      if (_this.props.scrollEventThrottle && _this.props.onScroll) {
        handleScroll = throttle(function (e) {
          _this.props.onScroll && _this.props.onScroll(e);
        }, _this.props.scrollEventThrottle);
      }
      return handleScroll;
    }, _this.scrollingComplete = function () {
      // console.log('scrolling complete');
      if (_this.props.refreshControl && _this.refs.refreshControl && _this.refs.refreshControl.state.deactive) {
        _this.refs.refreshControl.setState({ deactive: false });
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(ScrollView, [{
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      // https://stackoverflow.com/questions/1386696/make-scrollleft-scrolltop-changes-not-trigger-scroll-event
      // 问题情景：用户滚动内容后，改变 dataSource 触发 ListView componentWillReceiveProps
      // 内容变化后 scrollTop 如果改变、会自动触发 scroll 事件，而此事件应该避免被执行
      if ((this.props.dataSource !== nextProps.dataSource || this.props.initialListSize !== nextProps.initialListSize) && this.tsExec) {
        // console.log('componentWillUpdate');
        if (this.props.stickyHeader || this.props.useBodyScroll) {
          window.removeEventListener('scroll', this.tsExec);
        } else if (!this.props.useZscroller) {
          // not handle useZscroller now. todo
          ReactDOM.findDOMNode(this.refs[SCROLLVIEW]).removeEventListener('scroll', this.tsExec);
        }
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _this2 = this;

      // console.log('componentDidUpdate');
      if (prevProps.refreshControl && this.props.refreshControl) {
        var preRefreshing = prevProps.refreshControl.props.refreshing;
        var nowRefreshing = this.props.refreshControl.props.refreshing;
        if (preRefreshing && !nowRefreshing && this.refreshControlRefresh) {
          this.refreshControlRefresh();
        } else if (!this.manuallyRefresh && !preRefreshing && nowRefreshing) {
          this.domScroller.scroller.triggerPullToRefresh();
        }
      }
      // handle componentWillUpdate accordingly
      if ((this.props.dataSource !== prevProps.dataSource || this.props.initialListSize !== prevProps.initialListSize) && this.tsExec) {
        // console.log('componentDidUpdate');
        setTimeout(function () {
          if (_this2.props.stickyHeader || _this2.props.useBodyScroll) {
            window.addEventListener('scroll', _this2.tsExec);
          } else if (!_this2.props.useZscroller) {
            // not handle useZscroller now. todo
            ReactDOM.findDOMNode(_this2.refs[SCROLLVIEW]).addEventListener('scroll', _this2.tsExec);
          }
        }, 0);
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this3 = this;

      this.tsExec = this.throttleScroll();
      // IE supports onresize on all HTML elements.
      // In all other Browsers the onresize is only available at the window object
      this.onLayout = function () {
        return _this3.props.onLayout({
          nativeEvent: { layout: { width: window.innerWidth, height: window.innerHeight } }
        });
      };
      var ele = ReactDOM.findDOMNode(this.refs[SCROLLVIEW]);

      if (this.props.stickyHeader || this.props.useBodyScroll) {
        window.addEventListener('scroll', this.tsExec);
        window.addEventListener('resize', this.onLayout);
        // todo
        // ele.addEventListener('resize', this.onContentSizeChange);
      } else {
        // todo
        // ele.addEventListener('resize', this.onLayout);
        // ReactDOM.findDOMNode(this.refs[INNERVIEW])
        // .addEventListener('resize', this.onContentSizeChange);
        if (this.props.useZscroller) {
          this.renderZscroller();
        } else {
          ele.addEventListener('scroll', this.tsExec);
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.props.stickyHeader || this.props.useBodyScroll) {
        window.removeEventListener('scroll', this.tsExec);
        window.removeEventListener('resize', this.onLayout);
      } else if (this.props.useZscroller) {
        this.domScroller.destroy();
      } else {
        ReactDOM.findDOMNode(this.refs[SCROLLVIEW]).removeEventListener('scroll', this.tsExec);
      }
    }
  }, {
    key: 'scrollTo',
    value: function scrollTo() {
      if (this.props.stickyHeader || this.props.useBodyScroll) {
        var _window;

        (_window = window).scrollTo.apply(_window, arguments);
      } else if (this.props.useZscroller) {
        var _domScroller$scroller;

        // it will change zScroller's dimensions on data loaded, so it needs fire reflow.
        this.domScroller.reflow();
        (_domScroller$scroller = this.domScroller.scroller).scrollTo.apply(_domScroller$scroller, arguments);
      } else {
        var ele = ReactDOM.findDOMNode(this.refs[SCROLLVIEW]);
        ele.scrollLeft = arguments.length <= 0 ? undefined : arguments[0];
        ele.scrollTop = arguments.length <= 1 ? undefined : arguments[1];
      }
    }
  }, {
    key: 'renderZscroller',
    value: function renderZscroller() {
      var _this4 = this;

      var _props = this.props,
          scrollerOptions = _props.scrollerOptions,
          refreshControl = _props.refreshControl;
      // console.log('onRefresh will not change', refreshControl.props.onRefresh.toString());

      this.domScroller = new DOMScroller(ReactDOM.findDOMNode(this.refs[INNERVIEW]), assign({}, {
        scrollingX: false,
        onScroll: this.tsExec,
        scrollingComplete: this.scrollingComplete
      }, scrollerOptions));
      if (refreshControl) {
        var scroller = this.domScroller.scroller;
        var _refreshControl$props = refreshControl.props,
            distanceToRefresh = _refreshControl$props.distanceToRefresh,
            onRefresh = _refreshControl$props.onRefresh;

        scroller.activatePullToRefresh(distanceToRefresh, function () {
          // console.log('first reach the distance');
          _this4.manuallyRefresh = true;
          _this4.overDistanceThenRelease = false;
          _this4.refs.refreshControl && _this4.refs.refreshControl.setState({ active: true });
        }, function () {
          // console.log('back to the distance', this.overDistanceThenRelease);
          _this4.manuallyRefresh = false;
          _this4.refs.refreshControl && _this4.refs.refreshControl.setState({
            deactive: _this4.overDistanceThenRelease,
            active: false,
            loadingState: false
          });
        }, function () {
          // console.log('Over distance and release to loading');
          _this4.overDistanceThenRelease = true;
          _this4.refs.refreshControl && _this4.refs.refreshControl.setState({
            deactive: false,
            loadingState: true
          });
          var finishPullToRefresh = function finishPullToRefresh() {
            scroller.finishPullToRefresh();
            _this4.refreshControlRefresh = null;
          };
          Promise.all([new Promise(function (resolve) {
            onRefresh();
            _this4.refreshControlRefresh = resolve;
          }),
          // at lease 1s for ux
          new Promise(function (resolve) {
            return setTimeout(resolve, 1000);
          })]).then(finishPullToRefresh, finishPullToRefresh);
        });
        if (refreshControl.props.refreshing) {
          scroller.triggerPullToRefresh();
        }
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _classNames, _classNames2;

      var _props2 = this.props,
          children = _props2.children,
          className = _props2.className,
          _props2$prefixCls = _props2.prefixCls,
          prefixCls = _props2$prefixCls === undefined ? '' : _props2$prefixCls,
          _props2$listPrefixCls = _props2.listPrefixCls,
          listPrefixCls = _props2$listPrefixCls === undefined ? '' : _props2$listPrefixCls,
          _props2$listViewPrefi = _props2.listViewPrefixCls,
          listViewPrefixCls = _props2$listViewPrefi === undefined ? 'rmc-list-view' : _props2$listViewPrefi,
          _props2$style = _props2.style,
          style = _props2$style === undefined ? {} : _props2$style,
          contentContainerStyle = _props2.contentContainerStyle,
          useZscroller = _props2.useZscroller,
          refreshControl = _props2.refreshControl,
          stickyHeader = _props2.stickyHeader,
          useBodyScroll = _props2.useBodyScroll;


      var styleBase = styles.base;
      if (stickyHeader || useBodyScroll) {
        styleBase = null;
      } else if (useZscroller) {
        styleBase = styles.zScroller;
      }

      var preCls = prefixCls || listViewPrefixCls || '';

      var containerProps = {
        ref: SCROLLVIEW,
        style: assign({}, styleBase, style),
        className: classNames((_classNames = {}, _defineProperty(_classNames, className, !!className), _defineProperty(_classNames, preCls + '-scrollview', true), _classNames))
      };
      var contentContainerProps = {
        ref: INNERVIEW,
        style: assign({}, { position: 'absolute', minWidth: '100%' }, contentContainerStyle),
        className: classNames((_classNames2 = {}, _defineProperty(_classNames2, preCls + '-scrollview-content', true), _defineProperty(_classNames2, listPrefixCls, !!listPrefixCls), _classNames2))
      };

      if (refreshControl) {
        return React.createElement(
          'div',
          containerProps,
          React.createElement(
            'div',
            contentContainerProps,
            React.cloneElement(refreshControl, { ref: 'refreshControl' }),
            children
          )
        );
      }

      if (stickyHeader || useBodyScroll) {
        return React.createElement(
          'div',
          containerProps,
          children
        );
      }
      return React.createElement(
        'div',
        containerProps,
        React.createElement(
          'div',
          contentContainerProps,
          children
        )
      );
    }
  }]);

  return ScrollView;
}(React.Component);

ScrollView.propTypes = propTypes;
export default ScrollView;