import _extends from 'babel-runtime/helpers/extends';
import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import ListViewDataSource from './ListViewDataSource';
import ScrollView from './ScrollView';
import ScrollResponder from './ScrollResponder';
import StaticRenderer from './StaticRenderer';
import TimerMixin from 'react-timer-mixin';
import mixin from 'react-mixin';
import autobind from 'autobind-decorator';
import { StickyContainer, Sticky } from 'react-sticky';
import PullUpLoadMoreMixin from './PullUpLoadMoreMixin';

var DEFAULT_PAGE_SIZE = 1;
var DEFAULT_INITIAL_ROWS = 10;
var DEFAULT_SCROLL_RENDER_AHEAD = 1000;
var DEFAULT_END_REACHED_THRESHOLD = 1000;
var DEFAULT_SCROLL_CALLBACK_THROTTLE = 50;
var SCROLLVIEW_REF = 'listviewscroll';

// https://github.com/facebook/react-native/blob/master/Libraries/CustomComponents/ListView/ListView.js

/* eslint react/prop-types: 0, react/sort-comp: 0, no-unused-expressions: 0 */

var ListView = function (_React$Component) {
  _inherits(ListView, _React$Component);

  function ListView() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, ListView);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ListView.__proto__ || Object.getPrototypeOf(ListView)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      curRenderedRowsCount: _this.props.initialListSize,
      highlightedRow: {}

      /**
       * Exports some data, e.g. for perf investigations or analytics.
       */
    }, _this.stickyRefs = {}, _temp), _possibleConstructorReturn(_this, _ret);
  }

  /**
   * React life cycle hooks.
   */

  _createClass(ListView, [{
    key: 'getMetrics',
    value: function getMetrics() {
      return {
        contentLength: this.scrollProperties.contentLength,
        totalRows: this.props.dataSource.getRowCount(),
        renderedRows: this.state.curRenderedRowsCount,
        visibleRows: Object.keys(this._visibleRows).length
      };
    }

    /**
     * Provides a handle to the underlying scroll responder.
     * Note that the view in `SCROLLVIEW_REF` may not be a `ScrollView`, so we
     * need to check that it responds to `getScrollResponder` before calling it.
     */

  }, {
    key: 'getScrollResponder',
    value: function getScrollResponder() {
      return this.refs[SCROLLVIEW_REF] && this.refs[SCROLLVIEW_REF].getScrollResponder && this.refs[SCROLLVIEW_REF].getScrollResponder();
    }
  }, {
    key: 'scrollTo',
    value: function scrollTo() {
      var _refs$SCROLLVIEW_REF;

      this.refs[SCROLLVIEW_REF] && this.refs[SCROLLVIEW_REF].scrollTo && (_refs$SCROLLVIEW_REF = this.refs[SCROLLVIEW_REF]).scrollTo.apply(_refs$SCROLLVIEW_REF, arguments);
    }
  }, {
    key: 'setNativeProps',
    value: function setNativeProps(props) {
      this.refs[SCROLLVIEW_REF] && this.refs[SCROLLVIEW_REF].setNativeProps(props);
    }
  }, {
    key: 'getInnerViewNode',
    value: function getInnerViewNode() {
      return this.refs[SCROLLVIEW_REF].getInnerViewNode();
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      // this data should never trigger a render pass, so don't put in state
      this.scrollProperties = {
        visibleLength: null,
        contentLength: null,
        offset: 0
      };
      this._childFrames = [];
      this._visibleRows = {};
      this._prevRenderedRowsCount = 0;
      this._sentEndForContentLength = null;
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      // do this in animation frame until componentDidMount actually runs after
      // the component is laid out
      // this.requestAnimationFrame(() => {
      //   this._measureAndUpdateScrollProps();
      // });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (this.props.dataSource !== nextProps.dataSource || this.props.initialListSize !== nextProps.initialListSize) {
        this.setState(function (state, props) {
          _this2._prevRenderedRowsCount = 0;
          return {
            curRenderedRowsCount: Math.min(Math.max(state.curRenderedRowsCount, props.initialListSize), props.dataSource.getRowCount())
          };
        }, function () {
          return _this2._renderMoreRowsIfNeeded();
        });
      }
    }
  }, {
    key: 'onRowHighlighted',
    value: function onRowHighlighted(sectionID, rowID) {
      this.setState({ highlightedRow: { sectionID: sectionID, rowID: rowID } });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var bodyComponents = [];

      var dataSource = this.props.dataSource;
      var allRowIDs = dataSource.rowIdentities;
      var rowCount = 0;
      var sectionHeaderIndices = [];

      var header = this.props.renderHeader && this.props.renderHeader();
      var footer = this.props.renderFooter && this.props.renderFooter();
      var totalIndex = header ? 1 : 0;

      var _loop = function _loop(sectionIdx) {
        var sectionID = dataSource.sectionIdentities[sectionIdx];
        var rowIDs = allRowIDs[sectionIdx];
        if (rowIDs.length === 0) {
          return 'continue';
        }

        if (_this3.props.renderSectionHeader) {
          var shouldUpdateHeader = rowCount >= _this3._prevRenderedRowsCount && dataSource.sectionHeaderShouldUpdate(sectionIdx);

          var renderSectionHeader = React.createElement(StaticRenderer, {
            key: 's_' + sectionID,
            shouldUpdate: !!shouldUpdateHeader,
            render: _this3.props.renderSectionHeader.bind(null, dataSource.getSectionHeaderData(sectionIdx), sectionID)
          });
          if (_this3.props.stickyHeader) {
            renderSectionHeader = React.createElement(
              Sticky,
              _extends({}, _this3.props.stickyProps, { key: 's_' + sectionID,
                ref: function ref(c) {
                  _this3.stickyRefs[sectionID] = c;
                }
              }),
              renderSectionHeader
            );
          }
          bodyComponents.push(renderSectionHeader);
          sectionHeaderIndices.push(totalIndex++);
        }

        var sectionBody = [];
        for (var rowIdx = 0; rowIdx < rowIDs.length; rowIdx++) {
          var rowID = rowIDs[rowIdx];
          var comboID = sectionID + '_' + rowID;
          var shouldUpdateRow = rowCount >= _this3._prevRenderedRowsCount && dataSource.rowShouldUpdate(sectionIdx, rowIdx);
          var row = React.createElement(StaticRenderer, {
            key: 'r_' + comboID,
            shouldUpdate: !!shouldUpdateRow,
            render: _this3.props.renderRow.bind(null, dataSource.getRowData(sectionIdx, rowIdx), sectionID, rowID, _this3.onRowHighlighted)
          });
          // bodyComponents.push(row);
          sectionBody.push(row);
          totalIndex++;

          if (_this3.props.renderSeparator && (rowIdx !== rowIDs.length - 1 || sectionIdx === allRowIDs.length - 1)) {
            var adjacentRowHighlighted = _this3.state.highlightedRow.sectionID === sectionID && (_this3.state.highlightedRow.rowID === rowID || _this3.state.highlightedRow.rowID === rowIDs[rowIdx + 1]);
            var separator = _this3.props.renderSeparator(sectionID, rowID, adjacentRowHighlighted);
            if (separator) {
              // bodyComponents.push(separator);
              sectionBody.push(separator);
              totalIndex++;
            }
          }
          if (++rowCount === _this3.state.curRenderedRowsCount) {
            break;
          }
        }
        bodyComponents.push(React.cloneElement(_this3.props.renderSectionBodyWrapper(sectionID), {
          className: _this3.props.sectionBodyClassName
        }, sectionBody));
        if (rowCount >= _this3.state.curRenderedRowsCount) {
          return 'break';
        }
      };

      _loop2: for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
        var _ret2 = _loop(sectionIdx);

        switch (_ret2) {
          case 'continue':
            continue;

          case 'break':
            break _loop2;}
      }

      var _props = this.props,
          renderScrollComponent = _props.renderScrollComponent,
          props = _objectWithoutProperties(_props, ['renderScrollComponent']);

      bodyComponents = React.cloneElement(props.renderBodyComponent(), {}, bodyComponents);
      if (props.stickyHeader) {
        bodyComponents = React.createElement(
          StickyContainer,
          props.stickyContainerProps,
          bodyComponents
        );
      }

      this._sc = React.cloneElement(renderScrollComponent(_extends({}, props, { onScroll: this._onScroll })), {
        ref: SCROLLVIEW_REF,
        onContentSizeChange: this._onContentSizeChange,
        onLayout: this._onLayout
      }, header, bodyComponents, footer, props.children);
      return this._sc;
    }

    /**
     * Private methods
     */

  }, {
    key: '_measureAndUpdateScrollProps',
    value: function _measureAndUpdateScrollProps() {
      var scrollComponent = this.getScrollResponder();
      if (!scrollComponent || !scrollComponent.getInnerViewNode) {
        return;
      }

      // RCTScrollViewManager.calculateChildFrames is not available on
      // every platform
      // RCTScrollViewManager && RCTScrollViewManager.calculateChildFrames &&
      //   RCTScrollViewManager.calculateChildFrames(
      //     React.findNodeHandle(scrollComponent),
      //     this._updateVisibleRows,
      //   );
    }
  }, {
    key: '_onContentSizeChange',
    value: function _onContentSizeChange(width, height) {
      var contentLength = !this.props.horizontal ? height : width;
      if (contentLength !== this.scrollProperties.contentLength) {
        this.scrollProperties.contentLength = contentLength;
        this._updateVisibleRows();
        this._renderMoreRowsIfNeeded();
      }
      this.props.onContentSizeChange && this.props.onContentSizeChange(width, height);
    }
  }, {
    key: '_onLayout',
    value: function _onLayout(event) {
      var _event$nativeEvent$la = event.nativeEvent.layout,
          width = _event$nativeEvent$la.width,
          height = _event$nativeEvent$la.height;

      var visibleLength = !this.props.horizontal ? height : width;
      if (visibleLength !== this.scrollProperties.visibleLength) {
        this.scrollProperties.visibleLength = visibleLength;
        this._updateVisibleRows();
        this._renderMoreRowsIfNeeded();
      }
      this.props.onLayout && this.props.onLayout(event);
    }
  }, {
    key: '_maybeCallOnEndReached',
    value: function _maybeCallOnEndReached(event) {
      // console.log(this.scrollProperties, this._getDistanceFromEnd(this.scrollProperties));
      if (this.props.onEndReached &&
      // this.scrollProperties.contentLength !== this._sentEndForContentLength &&
      this._getDistanceFromEnd(this.scrollProperties) < this.props.onEndReachedThreshold && this.state.curRenderedRowsCount === this.props.dataSource.getRowCount()) {
        this._sentEndForContentLength = this.scrollProperties.contentLength;
        this.props.onEndReached(event);
        return true;
      }
      return false;
    }
  }, {
    key: '_renderMoreRowsIfNeeded',
    value: function _renderMoreRowsIfNeeded() {
      if (this.scrollProperties.contentLength === null || this.scrollProperties.visibleLength === null || this.state.curRenderedRowsCount === this.props.dataSource.getRowCount()) {
        this._maybeCallOnEndReached();
        return;
      }

      var distanceFromEnd = this._getDistanceFromEnd(this.scrollProperties);
      // console.log(distanceFromEnd, this.props.scrollRenderAheadDistance);
      if (distanceFromEnd < this.props.scrollRenderAheadDistance) {
        this._pageInNewRows();
      }
    }
  }, {
    key: '_pageInNewRows',
    value: function _pageInNewRows() {
      var _this4 = this;

      this.setState(function (state, props) {
        var rowsToRender = Math.min(state.curRenderedRowsCount + props.pageSize, props.dataSource.getRowCount());
        _this4._prevRenderedRowsCount = state.curRenderedRowsCount;
        return {
          curRenderedRowsCount: rowsToRender
        };
      }, function () {
        _this4._measureAndUpdateScrollProps();
        _this4._prevRenderedRowsCount = _this4.state.curRenderedRowsCount;
      });
    }
  }, {
    key: '_getDistanceFromEnd',
    value: function _getDistanceFromEnd(scrollProperties) {
      return scrollProperties.contentLength - scrollProperties.visibleLength - scrollProperties.offset;
    }
  }, {
    key: '_updateVisibleRows',
    value: function _updateVisibleRows() /* updatedFrames */{
      // if (!this.props.onChangeVisibleRows) {
      //   return; // No need to compute visible rows if there is no callback
      // }
      // if (updatedFrames) {
      //   updatedFrames.forEach((newFrame) => {
      //     this._childFrames[newFrame.index] = merge(newFrame);
      //   });
      // }
      // let isVertical = !this.props.horizontal;
      // let dataSource = this.props.dataSource;
      // let visibleMin = this.scrollProperties.offset;
      // let visibleMax = visibleMin + this.scrollProperties.visibleLength;
      // let allRowIDs = dataSource.rowIdentities;
      //
      // let header = this.props.renderHeader && this.props.renderHeader();
      // let totalIndex = header ? 1 : 0;
      // let visibilityChanged = false;
      // let changedRows = {};
      // for (let sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
      //   let rowIDs = allRowIDs[sectionIdx];
      //   if (rowIDs.length === 0) {
      //     continue;
      //   }
      //   let sectionID = dataSource.sectionIdentities[sectionIdx];
      //   if (this.props.renderSectionHeader) {
      //     totalIndex++;
      //   }
      //   let visibleSection = this._visibleRows[sectionID];
      //   if (!visibleSection) {
      //     visibleSection = {};
      //   }
      //   for (let rowIdx = 0; rowIdx < rowIDs.length; rowIdx++) {
      //     let rowID = rowIDs[rowIdx];
      //     let frame = this._childFrames[totalIndex];
      //     totalIndex++;
      //     if (!frame) {
      //       break;
      //     }
      //     let rowVisible = visibleSection[rowID];
      //     let min = isVertical ? frame.y : frame.x;
      //     let max = min + (isVertical ? frame.height : frame.width);
      //     if (min > visibleMax || max < visibleMin) {
      //       if (rowVisible) {
      //         visibilityChanged = true;
      //         delete visibleSection[rowID];
      //         if (!changedRows[sectionID]) {
      //           changedRows[sectionID] = {};
      //         }
      //         changedRows[sectionID][rowID] = false;
      //       }
      //     } else if (!rowVisible) {
      //       visibilityChanged = true;
      //       visibleSection[rowID] = true;
      //       if (!changedRows[sectionID]) {
      //         changedRows[sectionID] = {};
      //       }
      //       changedRows[sectionID][rowID] = true;
      //     }
      //   }
      //   if (!isEmpty(visibleSection)) {
      //     this._visibleRows[sectionID] = visibleSection;
      //   } else if (this._visibleRows[sectionID]) {
      //     delete this._visibleRows[sectionID];
      //   }
      // }
      // visibilityChanged && this.props.onChangeVisibleRows(this._visibleRows, changedRows);
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(e) {
      var isVertical = !this.props.horizontal;
      // this.scrollProperties.visibleLength = e.nativeEvent.layoutMeasurement[
      //   isVertical ? 'height' : 'width'
      // ];
      // this.scrollProperties.contentLength = e.nativeEvent.contentSize[
      //   isVertical ? 'height' : 'width'
      // ];
      // this.scrollProperties.offset = e.nativeEvent.contentOffset[
      //   isVertical ? 'y' : 'x'
      // ];
      var ev = e;
      // when the ListView is destroyed,
      // but also will trigger scroll event after `scrollEventThrottle`
      if (!this.refs[SCROLLVIEW_REF]) {
        return;
      }
      var target = ReactDOM.findDOMNode(this.refs[SCROLLVIEW_REF]);
      if (this.props.stickyHeader || this.props.useBodyScroll) {
        this.scrollProperties.visibleLength = window[isVertical ? 'innerHeight' : 'innerWidth'];
        this.scrollProperties.contentLength = target[isVertical ? 'scrollHeight' : 'scrollWidth'];
        this.scrollProperties.offset = window.document.body[isVertical ? 'scrollTop' : 'scrollLeft'];
      } else if (this.props.useZscroller) {
        var domScroller = this.refs[SCROLLVIEW_REF].domScroller;
        ev = domScroller;
        this.scrollProperties.visibleLength = domScroller.container[isVertical ? 'clientHeight' : 'clientWidth'];
        this.scrollProperties.contentLength = domScroller.content[isVertical ? 'offsetHeight' : 'offsetWidth'];
        this.scrollProperties.offset = domScroller.scroller.getValues()[isVertical ? 'top' : 'left'];
        // console.log(this.scrollProperties, domScroller.scroller.getScrollMax())
      } else {
        this.scrollProperties.visibleLength = target[isVertical ? 'offsetHeight' : 'offsetWidth'];
        this.scrollProperties.contentLength = target[isVertical ? 'scrollHeight' : 'scrollWidth'];
        this.scrollProperties.offset = target[isVertical ? 'scrollTop' : 'scrollLeft'];
      }

      // this._updateVisibleRows(e.nativeEvent.updatedChildFrames);
      if (!this._maybeCallOnEndReached(ev)) {
        this._renderMoreRowsIfNeeded();
      }

      if (this.props.onEndReached && this._getDistanceFromEnd(this.scrollProperties) > this.props.onEndReachedThreshold) {
        // Scrolled out of the end zone, so it should be able to trigger again.
        this._sentEndForContentLength = null;
      }

      this.props.onScroll && this.props.onScroll(ev);
    }
  }]);

  return ListView;
}(React.Component);

ListView.DataSource = ListViewDataSource;
ListView.propTypes = _extends({}, ScrollView.propTypes, {
  dataSource: PropTypes.instanceOf(ListViewDataSource).isRequired,
  renderSeparator: PropTypes.func,
  renderRow: PropTypes.func.isRequired,
  initialListSize: PropTypes.number,
  onEndReached: PropTypes.func,
  onEndReachedThreshold: PropTypes.number,
  pageSize: PropTypes.number,
  renderFooter: PropTypes.func,
  renderHeader: PropTypes.func,
  renderSectionHeader: PropTypes.func,
  renderScrollComponent: PropTypes.func,
  scrollRenderAheadDistance: PropTypes.number,
  onChangeVisibleRows: PropTypes.func,
  scrollEventThrottle: PropTypes.number,
  // removeClippedSubviews: PropTypes.bool,
  // stickyHeaderIndices: PropTypes.arrayOf(PropTypes.number),
  // another added
  renderBodyComponent: PropTypes.func,
  renderSectionBodyWrapper: PropTypes.func,
  sectionBodyClassName: PropTypes.string,
  useZscroller: PropTypes.bool, // for web
  useBodyScroll: PropTypes.bool, // for web
  stickyHeader: PropTypes.bool, // for web
  stickyProps: PropTypes.object, // https://github.com/captivationsoftware/react-sticky/blob/master/README.md#sticky--props
  stickyContainerProps: PropTypes.object });
ListView.defaultProps = {
  initialListSize: DEFAULT_INITIAL_ROWS,
  pageSize: DEFAULT_PAGE_SIZE,
  renderScrollComponent: function renderScrollComponent(props) {
    return React.createElement(ScrollView, props);
  },
  renderBodyComponent: function renderBodyComponent() {
    return React.createElement('div', null);
  },
  renderSectionBodyWrapper: function renderSectionBodyWrapper(sectionID) {
    return React.createElement('div', { key: sectionID });
  },
  sectionBodyClassName: 'list-view-section-body',
  scrollRenderAheadDistance: DEFAULT_SCROLL_RENDER_AHEAD,
  onEndReachedThreshold: DEFAULT_END_REACHED_THRESHOLD,
  scrollEventThrottle: DEFAULT_SCROLL_CALLBACK_THROTTLE,
  // stickyHeaderIndices: [],
  stickyProps: {},
  stickyContainerProps: {}
};


mixin(ListView.prototype, ScrollResponder.Mixin);
mixin(ListView.prototype, TimerMixin);
mixin(ListView.prototype, PullUpLoadMoreMixin);
autobind(ListView);

ListView.isReactNativeComponent = true;

export default ListView;